# OS
SCUT操作系统课程大作业：论文审稿系统  
## 1. 目录结构说明
```
.
├── filesystem                  # 文件系统项目根目录
│   ├── bin                     # 编译输出目录，存放可执行文件
│   │   ├── mkfs                # 文件系统格式化工具可执行文件
│   │   └── test_filesystem     # 文件系统测试程序可执行文件
│   ├── disk                    # 磁盘镜像目录
│   │   └── disk.img            # 10MB的磁盘镜像文件
│   ├── include                 # 头文件目录
│   │   ├── disk.h              # 磁盘操作相关定义和函数声明
│   │   └── inode.h             # inode相关定义和函数声明
│   ├── scripts                 # 脚本和工具程序源码目录
│   │   ├── mkfs.cpp            # 文件系统格式化工具源代码
│   │   └── mkfs.o              # mkfs.cpp编译生成的目标文件
│   ├── src                     # 核心源代码目录
│   │   ├── disk.cpp            # 磁盘操作函数实现
│   │   ├── disk.o              # disk.cpp编译生成的目标文件
│   │   ├── inode.cpp           # inode操作函数实现
│   │   ├── inode.o             # inode.cpp编译生成的目标文件
│   │   └── makefile            # 项目构建规则文件
│   └── test                    # 测试代码目录
│       ├── test_filesystem.cpp # 文件系统完整功能测试程序源代码
│       └── test_filesystem.o   # 测试程序编译生成的目标文件
├── server                       # Server 模块根目录（C++ TCP 服务端）
│   ├── CMakeLists.txt           # Server 构建配置
│   ├── main.cpp                 # 入口：TCP监听、并发处理连接
│   ├── note.txt                 # 简要运行/测试记录
│   ├── readme.md                # Server 设计与模块说明
│   ├── include/                 # 头文件
│   │   ├── auth/                # 用户/会话/权限
│   │   ├── business/            # 业务流程编排（备份/审核等）
│   │   ├── cache/               # LRU缓存（server侧可选）
│   │   └── protocol/            # CLI协议解析 + FS调用抽象
│   ├── src/                     # 源文件实现
│   │   ├── auth/
│   │   ├── business/
│   │   ├── cache/
│   │   └── protocol/
│   └── test/
│       └── test_client.py       # Python CLI 客户端（用于联调server）
└── README.md                   # 项目说明文档
```

说明：
- filesystem 负责“磁盘/目录/文件/快照/LRU”等底层数据结构与统一 API；
- server 负责“网络并发、协议解析、用户/会话、权限校验、业务编排”，并通过 FSProtocol 调用文件系统。
  
## 2. 设计文档
![os1](https://github.com/user-attachments/assets/7a5e74fc-87c2-4fd6-9b0c-90ed27e5af60)
![os2](https://github.com/user-attachments/assets/1dc7c74e-4302-43fa-b112-cfff4340dbea)

## 3. 相关笔记
### 运算符
| 运算符 | 类型     | 在代码中的应用                                               | 功能说明                                         | 示例代码                                       |
|--------|----------|--------------------------------------------------------------|--------------------------------------------------|------------------------------------------------|
| &      | 按位与   | `buf[byte_index] & (1 << bit_index)`                         | 检查特定位是否为1                                | `if (!(buf[byte_index] & (1 << bit_index)))`   |
| \|     | 按位或   | `buf[i / 8] \|= (1 << (i % 8))`                              | 设置特定位为1                                    | `buf[byte_index] \|= (1 << bit_index)`          |
| &=     | 按位与赋值 | `buf[byte_index] &= ~(1 << bit_index)`                       | 清除特定位（设为0）                              | `buf[byte_index] &= ~(1 << bit_index)`          |
| ~      | 按位取反 | `~(1 << bit_index)`                                          | 创建位掩码，目标位为0，其他位为1                  | `buf[byte_index] &= ~(1 << bit_index)`          |
| <<     | 左移     | `1 << bit_index`                                             | 创建只有目标位为1的掩码                          | `1 << (i % 8)`                                 |
| !      | 逻辑非   | `!(buf[byte_index] & (1 << bit_index))`                      | 取反逻辑值，用于判断位是否为0                    | `if (!(buf[byte_index] & (1 << bit_index)))`   |
| /      | 除法     | `i / 8`                                                      | 计算字节索引                                     | `int byte_index = i / 8`                       |
| %      | 取模     | `i % 8`                                                      | 计算位在字节内的索引                             | `int bit_index = i % 8`                        |
| *      | 乘法     | `BLOCK_SIZE * 8`                                             | 计算总位数                                       | `i < BLOCK_SIZE * 8`                           |
| -      | 减法     | `BLOCK_COUNT - DATA_BLOCK_START`                             | 计算可用数据块数量                               | `sb.free_block_count = BLOCK_COUNT - DATA_BLOCK_START` |
| []     | 下标     | `buf[byte_index]`                                            | 访问数组元素                                     | `buf[byte_index]`                              |
| .      | 成员访问 | `sb.block_size`                                              | 访问结构体成员                                   | `sb.block_size = BLOCK_SIZE`                   |
| sizeof | 大小运算 | `sizeof(sb)`                                                 | 获取数据类型的大小                               | `memcpy(buf, &sb, sizeof(sb))`                 |
| ()     | 函数调用 | `read_block(fd, INODE_BITMAP_BLOCK, buf)`                    | 调用函数                                         | `read_block(fd, INODE_BITMAP_BLOCK, buf)`      |

### 核心位操作模式
1. **位检测**: `buf[index] & (1 << bit_pos)` - 检查某位是否为1
2. **位置1**: `buf[index] |= (1 << bit_pos)` - 将某位设置为1
3. **位清0**: `buf[index] &= ~(1 << bit_pos)` - 将某位设置为0
4. **索引计算**: `index = pos / 8`, `bit_pos = pos % 8` - 将线性位置映射到位图坐标

### 系统调用
| 函数   | 用途         | 在代码中的应用                                   |
|--------|--------------|--------------------------------------------------|
| open   | 打开文件     | `open(path, O_RDWR \| O_CREAT, 0666)`              |
| close  | 关闭文件     | `close(fd)`                                      |
| lseek  | 移动文件指针 | `lseek(fd, offset, SEEK_SET)`                    |
| read   | 读取文件     | `read(fd, buf, BLOCK_SIZE)`                      |
| write  | 写入文件     | `write(fd, buf, BLOCK_SIZE)`                     |

### 文件操作模式
- `O_RDWR`: 读写模式打开文件
- `O_CREAT`: 文件不存在时创建
- `SEEK_SET`: 从文件开头计算偏移量

### 重要常量和宏

| 常量名                 | 值  | 用途说明              |
|------------------------|-----|-----------------------|
| BLOCK_SIZE             | 1024| 磁盘块大小(1KB)       |
| DISK_SIZE              | 10M | 磁盘总大小            |
| SUPERBLOCK_BLOCK       | 0   | 超级块位置            |
| INODE_BITMAP_BLOCK     | 1   | inode位图位置         |
| BLOCK_BITMAP_BLOCK     | 2   | 数据块位图位置        |
| INODE_TABLE_START      | 3   | inode表起始位置       |

